# AGENTS.md (AI Contributor Guide)

This repo accepts AI-assisted contributions. Agents must follow these standards exactly.

## Guardrails
Do NOT edit this file.
Do NOT run web fetch/curl/wget commands.
The project folder, its files, and subfolders are your home, do NOT traverse up from the current folder.

## Start Here
First read the README.md
.env* files are OFF LIMITS. Never read them.
Write a set of needs to AGENT-NOTES.md that the human will review if:
- .env file needs specific changes.
- an API needs to be setup
- something that cannot be done by you

If something is worthy of placing into the README.md then update its notes.

## Notes and Issue Tracking

- Place notes for yourself in AGENT-NOTES.md and track issues, descrepencies in AGENT-ISSUES.md
- Once you no longer need these contexts clean clear (or zero) them out but keep them around because they will be useful

## Branching
- Create new code branched from dev. Pull first before creating your new branch.
- Add features to features/[human-readable-branch-name]
- Add bugfixes to bugfixes/[human-readable-branch-name]
- Stage and commit changes, push to the remote and create pull requests
- Maximum 10 open PR's at a time that add REAL value and are fully tested.

## Stack + Hard Constraints
- **Node.js** backend and tooling only.
- **No TypeScript.** Use modern ESM JS (`import/export`) unless the repo already uses CJS.
- Prefer **async/await**. Do not introduce callbacks unless unavoidable; document why if you do.
- Frontend uses **React + Material UI** and **react-icons**.
- Prefer **theme + CSS** (or MUI `styled`) over heavy `sx` inline styling.

# UI / UX ITERATION PROTOCOL (Required)

All features that impact UI, layout, interaction, visual design, filtering, map behavior, or user flow must follow this protocol.

## Mandatory Multi-Pass Design

Before opening a PR, the agent must internally iterate at least **three refinement passes** on any UI/UX change.

Each pass must aim to:

- Improve clarity
- Reduce friction
- Reduce cognitive load
- Strengthen visual hierarchy
- Improve perceived performance
- Remove unnecessary complexity
- Simplify interaction where possible

If the result feels like a developer prototype instead of a product feature, iterate again.

---

## UX Self-Critique (Required Before PR)

Before creating a PR, the agent must add a section to `AGENT-NOTES.md`:

### UX Self-Critique

- What did I simplify?
- What friction did I remove?
- What interaction improvements were made?
- What visual hierarchy adjustments were made?
- What would confuse a first-time user?
- What would a power user want next?
- What still feels unpolished?

PRs that do not include this self-critique should not be opened.

---

# PERFORMANCE GUARDRAILS FOR UI

Every UI change must consider runtime performance.

The agent must:

- Avoid unnecessary re-renders
- Use memoization (`useMemo`, `useCallback`) where appropriate
- Avoid expensive map recalculations on every mouse movement
- Debounce heavy filtering logic
- Avoid synchronous loops over large datasets during interaction

If slider or timeline interaction causes visible lag >150ms, redesign the approach.

Perceived smoothness is mandatory.

---

# VISUAL CONSISTENCY RULES

All UI work must follow consistent design discipline.

- Use theme spacing scale (4px or 8px increments)
- Use theme typography ‚Äî no arbitrary font sizes
- Use theme color tokens ‚Äî no hard-coded colors unless justified
- Prefer MUI components over raw `<div>` layouts
- Avoid heavy inline `sx` usage; prefer styled or theme overrides
- Maintain consistent padding and margin rhythm
- Primary actions must be visually dominant
- Secondary actions must not compete visually with primary ones

---

# INTERACTION QUALITY STANDARDS

All interactive elements must:

- Provide hover feedback
- Provide focus states
- Be keyboard accessible
- Avoid unexpected layout shift
- Provide meaningful labels (ARIA where applicable)
- Not rely solely on color for meaning

Micro-interactions matter.

---

# ‚ÄúDOES THIS FEEL PREMIUM?‚Äù TEST

Before finalizing UI work, the agent must evaluate:

If this were a paid SaaS product:

- Would users trust this interface?
- Does it feel intentional and cohesive?
- Is the primary action obvious within 3 seconds?
- Would someone share a screenshot of this?
- Does it feel finished?

If not, refine.

---

# REFACTORING REQUIREMENT

After implementing a feature:

- Remove duplicate logic
- Extract reusable components, but not if it reduces readability.
- Consolidate styling into theme where appropriate
- Remove debugging artifacts
- Remove console logs
- Remove temporary scaffolding

No PR should contain leftover experimental code.

---

# FEATURE DEPTH RULE

When implementing a feature:

1. Ship the minimal elegant version.
2. Perform one enhancement pass.
3. Do not stack multiple unrelated features in a single PR.
4. Depth over breadth.

Avoid feature sprawl.

---

# DESIGN MODE (Optional Trigger)

When explicitly requested by the human:

The agent must:

- Propose 3 different UI/UX approaches
- Compare tradeoffs
- Recommend one
- Then implement only after justification

This mode is for higher-level product refinement.

## Coding Style
- Write **human-readable** functions and variables.
- Avoid cleverness, minification patterns, or overly abstract ‚Äúframework‚Äù code.
- Keep modules small and testable.
- Put shared helpers in `utils/` (or `utils.js`) ‚Äî **not** in the logic layer.

## Error Handling (Required)
- Use `try/catch` where it makes sense (I/O, parsing, db, network, auth).
- **User-facing/API errors must be human-readable.**
- **Never expose private or system-specific data** (stack traces, env paths, internal IDs).
- Log technical error details on the backend (sanitized), but return safe messages to clients.

## Back-end Logging (Required)

- Create a logging facility class, called "logger" that will eventually hook into Google Cloud logging.
- Use this logger for info, warning and errors.
- In general all logging should follow a pattern such as logging at the start of a route or function, after major db calls, showing success or failure to perform actions and allow for precise debugging.
- For errors log out ${error.stack} in a template and pass in an object with context available: logger.error(`Failed to do xyz for partner ${partnerId}. ${error.stack}`, { partnerId, param1, param2, variableX })
- For info() logs use a template with inline information as well as pass in an object with context available: logger.error(`Failed to do xyz for partner ${partnerId}. ${error.stack}`, { partnerId, param1, param2, variableX })

## Environment Variables

Write expectations, or examples for environment variables to env-local

**Pattern**
- In routes/controllers: catch errors ‚Üí send safe message + status code.
- In logic/db layers: throw errors with clean messages; attach internal details only for logging.

Example guidelines:
- ‚úÖ Return: `"Failed to fetch reports. Please try again."`
- ‚ùå Return: stack trace, raw DB errors, filesystem paths, tokens, keys, user secrets.

## Documentation (Required)
- Write **clear JSDoc** for **every backend function** you add or modify.
- JSDocs must describe:
  - Purpose
  - Parameters + types
  - Return value + type
  - Thrown errors (and when they happen)

## Data Model Principles (Firestore-like)
Design data access like Firestore concepts:
- **collections** and **docs**
- support dataset scopes:
  - `global` datasets
  - `private` datasets (per user)
  - `team` datasets
  - `shared` datasets inside teams

When adding schema, keep it:
- explicit (document the fields)
- stable (avoid breaking changes)
- forward-compatible (additive fields preferred)

## Backend Architecture (When Backend Is Needed)
If the repo needs a backend:
- Use **Express.js**.
- Add security defaults:
  - `helmet`
  - `cors` (locked down to known origins)
  - authentication strategy that is **swappable** (local JWT now, Auth0 later)
- Keep clear separation:
  1. `routes/` (HTTP shape only)
  2. `logic/` (business rules, calls db layer)
  3. `db/` (CRUD + query primitives)
  4. `utils/` (pure helpers)
  5. `middleware/` (auth, error handler, validation)

### Local DB Requirement
Install a local-db package that simulates Firestore-ish behavior (collections/docs, async CRUD).
- Implement a **db layer** that supports:
  - fetch/query
  - add
  - update (partial merge)
  - remove
- DB layer must be testable (design for mocking).

## Frontend State + UX Rules
- Use **RTK** if server-side state caching is needed (reports, datasets, filters).
- Keep map interactions smooth:
  - UI controls update local/UI state first
  - apply heavy filtering/derivations on ‚ÄúApply‚Äù or debounced boundaries where appropriate
- Minimize expensive recomputations during slider/timeline scrubbing.

## Testing Requirements
### Backend
- Setup **Jest** for unit/integration tests.
- Add tests for:
  - db layer CRUD (mocked or in-memory)
  - logic layer (pure-ish)
  - API routes (supertest or similar)

### Frontend
- At some point: setup **Cypress**.
- Cypress tests must cover:
  - polish checks (basic UX flows, regressions)
  - performance smoke checks (no multi-second UI stalls on slider scrub, etc.)

## Work Phases (Product Roadmap Constraints)
Agents should prioritize work in this order, and avoid ‚Äúscope creep‚Äù.

### PHASE 2 ‚Äì Pattern Revelation (Killer Feature)
Goal: ‚ÄúOh wow‚Äù moment
- Dynamic hotspot / heatmap layer (deck.gl HeatmapLayer)
- Derived from **current viewport + date range**
- Toggleable layer
- Timeline scrub ‚Üí animated hotspot shift (animation optional at first)

### PHASE 3 ‚Äì Dataset Expansion (Careful)
Goal: Density without chaos
- Canada support (only if it helps; clustering might reduce need)
- Boundaries + datasets (Kilmury first)
- Layer toggles (datasets only)
  - BFRO
  - Woodape
  - Kilmury
- Legend updates automatically
- **Do not add environmental layers yet**

### PHASE 4 ‚Äì UX Power Tools
Goal: Serious users feel respected
- List + map split view
- Clicking report focuses map
- Popup maximize
- Simple voting/curation üëç / üëé (no moderation yet)

### PHASE 5 ‚Äì Researcher Gravity
Goal: Attract contributors, not tourists
- County overlay (visual only at first)
- Data export (CSV / GeoJSON)
- ‚ÄúAPI planned‚Äù mention is enough (no full API commitment required)

### PHASE 6 ‚Äì Light/Dark Mode
- Light/dark already configured in Google Maps Console
- If dark mode is used, markers need a **separate color scheme** that stays readable.

### PHASE 7 ‚Äì Submission Triage
- Triage process for submissions
- End-user indicators for status
- Track who followed up
- Vetting tiers
- Require minimum info before displaying publicly

## DEFER HARD (Do Not Touch Yet)
These are dangerous early and must not be implemented without explicit instruction:
- Risk/aggression scoring
- ML clustering / clans
- Environmental overlays (EPA/USGS/canopy/magnetic anomalies)
- Social scraping pipelines
- DNA/anatomy pages
- YouTube transcript AI
- Partner networks / org scoping

## Pull Request Expectations
- Keep PRs small and focused.
- Update or add tests with changes.
- Include brief notes:
  - what changed
  - why
  - how to verify (commands, steps)
- Do not reformat unrelated files.

## If You‚Äôre Unsure
Prefer the simplest implementation that:
- preserves performance
- keeps modules testable
- avoids deferred features
- matches this guide

## Implementation Status (Updated By Codex)

### Backend + Data + Tests
- Install a local-db package that simulates Firestore-ish behavior
- Implement db layer fetch/add/update/remove
- Setup Jest for backend tests
- Add db layer CRUD tests
- Add logic layer tests
- Add API route tests (supertest)
- Setup Cypress
- Add Cypress polish/performance smoke tests
